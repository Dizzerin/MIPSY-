0 LineType.COMMENT     ########################################################################
1 LineType.COMMENT     #   Description:	Problem 2.25 in MIPS
2 LineType.COMMENT     #   Filename:		Caleb_Nelson_CPTR_380_HW_7
3 LineType.COMMENT     #   Author:      	Caleb Nelson
4 LineType.COMMENT     #   Version:     	1/25/22
5 LineType.COMMENT     #   Processor:   	MIPS
6 LineType.COMMENT     #   Notes:       	For execution using the SPIM simulator
7 LineType.COMMENT     #
8 LineType.COMMENT     #	This program SUCCESSFULLY implements this C code:
9 LineType.COMMENT     #
10 LineType.COMMENT     #	for(i=0;i<a;i++){
11 LineType.COMMENT     #		for(j=0;j<b;j++){
12 LineType.COMMENT     #			D[4*j]=i+j
13 LineType.COMMENT     #		}
14 LineType.COMMENT     #	}
15 LineType.COMMENT     #
16 LineType.COMMENT     #	Note: This C code is slightly pointless because it simply overwrites the same elements in D
17 LineType.COMMENT     #	Also, since we don't know the original element type and data size of the elements intended to be
18 LineType.COMMENT     #	store in D, it is unclear whether D[4*j] means we are accessing every 4th element (and skipping over the rest)
19 LineType.COMMENT     #	or whether that is just the book trying to indicate that we would need to multiply the index variable by 4
20 LineType.COMMENT     #	to convert to a word address from an index since there are 4 bytes in each word.
21 LineType.COMMENT     #	I took the approach of assuming the latter; Assumming that D is an array of words (so each element occupies 4 bytes)
22 LineType.COMMENT     #	and that we are accessing every element, not every 4th element as would actually occur in the explicitly given C code.
23 LineType.COMMENT     #	
24 LineType.COMMENT     #	To put it more explicitly, I implemented the following:
25 LineType.COMMENT     #
26 LineType.COMMENT     #	some_type_with_4_byte_length arrayD[4];
27 LineType.COMMENT     #	// other var initiliaization here
28 LineType.COMMENT     #	// main loops
29 LineType.COMMENT     #	for(i=0;i<a;i++){
30 LineType.COMMENT     #		for(j=0;j<b;j++){
31 LineType.COMMENT     #			D[j]=i+j
32 LineType.COMMENT     #		}
33 LineType.COMMENT     #	}
34 LineType.COMMENT     #	
35 LineType.COMMENT     # 	Variable/Register Notes:
36 LineType.COMMENT     #	$s0 --> a
37 LineType.COMMENT     #	$s1 --> b
38 LineType.COMMENT     #	$t0 --> i
39 LineType.COMMENT     #	$t1 --> j
40 LineType.COMMENT     #	$t2	-->	sum (i+j)
41 LineType.COMMENT     #	$t3 --> byte offset amount
42 LineType.COMMENT     #	$s2 --> base address of array D
43 LineType.COMMENT     #	$t4	-->	current address of array D
44 LineType.COMMENT     #	$t5	-->	address of varA
45 LineType.COMMENT     #	$t6	-->	address of varB
46 LineType.COMMENT     #
47 LineType.COMMENT     #	Results:
48 LineType.COMMENT     #		This code has been tested with a few values of a and b and works as expected!
49 LineType.COMMENT     #		Currently a = 3 and b = 4, with these settings, the inner loop with execute 4 times
50 LineType.COMMENT     #		and the outer loop will execute 3 times.
51 LineType.COMMENT     #		D will contain the following after each pass of the outer loop
52 LineType.COMMENT     #		i=0: 0 1 2 3
53 LineType.COMMENT     #		i=1: 1 2 3 4
54 LineType.COMMENT     #		i=2: 2 3 4 5
55 LineType.COMMENT     ########################################################################
56 LineType.BLANK     
57 LineType.ASSM_DIRECTIVE     		.data
58 LineType.VARIABLE     arrayD:	.space 16		# 16 bytes (4 words) reserved for arrayD
59 LineType.VARIABLE     varA: 	.word	3		# desired outer loop count
60 LineType.VARIABLE     varB:	.word	4		# desired inner loop count
61 LineType.BLANK     
62 LineType.ASSM_DIRECTIVE     		.text
63 LineType.LABEL_ONLY     main:	
64 LineType.I_INSTRUCTION     	ori $t0, $0, 0 		# set t0 (i) to zero
65 LineType.U_INSTRUCTION     	la $s2, arrayD 		# get address of arrayD
66 LineType.COMMENT     	#ori $s0, $0, 3 	# set s0 (a) to 3 (commented out since I think we are supposed to use the variable method instead, could also use move command instead of ori)
67 LineType.COMMENT     	#ori $s1, $0, 4 	# set s1 (b) to 4 (commented out since I think we are supposed to use the variable method instead, could also use move command instead of ori)
68 LineType.COMMENT     	# Last 2 lines above using variables instead of immediate values:
69 LineType.U_INSTRUCTION     	la $t5, varA 		# place the address of A into register t5
70 LineType.I_INSTRUCTION     	lw $s0, 0($t5) 		# get the outer loop count from varA
71 LineType.U_INSTRUCTION     	la $t6, varB 		# place the address of B into register t6
72 LineType.I_INSTRUCTION     	lw $s1, 0($t6) 		# get the inner loop count from varB
73 LineType.BLANK     	
74 LineType.LABEL_ONLY     outer_loop:
75 LineType.COMMENT     	# Skip/exit loop if condition is not met
76 LineType.U_INSTRUCTION     	bge $t0, $s0, exit 				# go to exit if i >= a
77 LineType.I_INSTRUCTION     	ori $t1, $0, 0 					# set t1 (j) to zero
78 LineType.BLANK     
79 LineType.LABEL_ONLY     	inner_loop:
80 LineType.COMMENT     		# Skip/exit loop if condition is not met
81 LineType.U_INSTRUCTION     		bge $t1, $s1, inner_exit 	# go to exit if j >= b
82 LineType.BLANK     		
83 LineType.COMMENT     		# Compute sum
84 LineType.R_INSTRUCTION     		add $t2, $t0, $t1			# $t2 = i + j
85 LineType.BLANK     		
86 LineType.COMMENT     		# Get address of D[4*j]
87 LineType.R_INSTRUCTION     		sll $t3, $t1, 2 			# $t3 = byte offset amount (j*4)
88 LineType.R_INSTRUCTION     		add $t4, $s2, $t3 			# address = $t4 = base address + byte offset
89 LineType.BLANK     		
90 LineType.COMMENT     		# Store at D[4*j]
91 LineType.I_INSTRUCTION     		sw $t2, 0($t4)				# store $t2 at D[4*j] if j is byte offset or D[j] if you consider it a word offset
92 LineType.BLANK     		
93 LineType.COMMENT     		# Increment j				# lots # of # comment # symbols # # # #
94 LineType.I_INSTRUCTION     		addi $t1, $t1, 1
95 LineType.BLANK     		
96 LineType.COMMENT     		# loop
97 LineType.J_INSTRUCTION     		j inner_loop
98 LineType.BLANK     	
99 LineType.LABEL_ONLY     	inner_exit:
100 LineType.BLANK     	
101 LineType.COMMENT     	# Increment i
102 LineType.I_INSTRUCTION     	addi $t0, $t0, 1
103 LineType.BLANK     	
104 LineType.COMMENT     	# loop
105 LineType.J_INSTRUCTION     	j outer_loop
106 LineType.BLANK     
107 LineType.LABEL_WITH_R_INSTR     labelwithR: add $s0, $s0, $s0
108 LineType.LABEL_WITH_I_INSTR     labelwithI: addi $s0, $s0, 1
109 LineType.LABEL_WITH_J_INSTR     labelwithJ: j labelHere
110 LineType.LABEL_WITH_U_INSTR     labelwithU:	sxs					# comment on line with label and instruction
111 LineType.BLANK     
112 LineType.LABEL_WITH_I_INSTR     exit:	addi	$v0, $0, 10	# terminate the program with system call #10
113 LineType.INVALID     	syscall
