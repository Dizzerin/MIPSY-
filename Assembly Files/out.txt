LineType.COMMENT		########################################################################
LineType.COMMENT		#   Description:	Problem 2.25 in MIPS
LineType.COMMENT		#   Filename:		Caleb_Nelson_CPTR_380_HW_7
LineType.COMMENT		#   Author:      	Caleb Nelson
LineType.COMMENT		#   Version:     	1/25/22
LineType.COMMENT		#   Processor:   	MIPS
LineType.COMMENT		#   Notes:       	For execution using the SPIM simulator
LineType.COMMENT		#
LineType.COMMENT		#	This program SUCESSFULLY implements this C code:
LineType.COMMENT		#
LineType.COMMENT		#	for(i=0;i<a;i++){
LineType.COMMENT		#		for(j=0;j<b;j++){
LineType.COMMENT		#			D[4*j]=i+j
LineType.COMMENT		#		}
LineType.COMMENT		#	}
LineType.COMMENT		#
LineType.COMMENT		#	Note: This C code is slightly pointless because it simply overwrites the same elements in D
LineType.COMMENT		#	Also, since we don't know the original element type and data size of the elements intended to be
LineType.COMMENT		#	store in D, it is unclear whether D[4*j] means we are accessing every 4th element (and skipping over the rest)
LineType.COMMENT		#	or whether that is just the book trying to indicate that we would need to multiply the index variable by 4
LineType.COMMENT		#	to convert to a word address from an index since there are 4 bytes in each word.
LineType.COMMENT		#	I took the approach of assuming the latter; Assumming that D is an array of words (so each element occupies 4 bytes)
LineType.COMMENT		#	and that we are accessing every element, not every 4th element as would actually occur in the explicitly given C code.
LineType.COMMENT		#	
LineType.COMMENT		#	To put it more explicitly, I implemented the following:
LineType.COMMENT		#
LineType.COMMENT		#	some_type_with_4_byte_length arrayD[4];
LineType.COMMENT		#	// other var initiliaization here
LineType.COMMENT		#	// main loops
LineType.COMMENT		#	for(i=0;i<a;i++){
LineType.COMMENT		#		for(j=0;j<b;j++){
LineType.COMMENT		#			D[j]=i+j
LineType.COMMENT		#		}
LineType.COMMENT		#	}
LineType.COMMENT		#	
LineType.COMMENT		# 	Variable/Register Notes:
LineType.COMMENT		#	$s0 --> a
LineType.COMMENT		#	$s1 --> b
LineType.COMMENT		#	$t0 --> i
LineType.COMMENT		#	$t1 --> j
LineType.COMMENT		#	$t2	-->	sum (i+j)
LineType.COMMENT		#	$t3 --> byte offset amount
LineType.COMMENT		#	$s2 --> base address of array D
LineType.COMMENT		#	$t4	-->	current address of array D
LineType.COMMENT		#	$t5	-->	address of varA
LineType.COMMENT		#	$t6	-->	address of varB
LineType.COMMENT		#
LineType.COMMENT		#	Results:
LineType.COMMENT		#		This code has been tested with a few values of a and b and works as expected!
LineType.COMMENT		#		Currently a = 3 and b = 4, with these settings, the inner loop with execute 4 times
LineType.COMMENT		#		and the outer loop will execute 3 times.
LineType.COMMENT		#		D will contain the following after each pass of the outer loop
LineType.COMMENT		#		i=0: 0 1 2 3
LineType.COMMENT		#		i=1: 1 2 3 4
LineType.COMMENT		#		i=2: 2 3 4 5
LineType.COMMENT		########################################################################
LineType.BLANK		
LineType.ASSM_DIRECTIVE				.data
LineType.VARIABLE		arrayD:	.space 16		# 16 bytes (4 words) reserved for arrayD
LineType.VARIABLE		varA: 	.word	3		# desired outer loop count
LineType.VARIABLE		varB:	.word	4		# desired inner loop count
LineType.BLANK		
LineType.ASSM_DIRECTIVE				.text
LineType.LABEL_ONLY		main:	
LineType.INVALID			ori $t0, $0, 0 		# set t0 (i) to zero
LineType.INVALID			la $s2, arrayD 		# get address of arrayD
LineType.COMMENT			#ori $s0, $0, 3 	# set s0 (a) to 3 (commented out since I think we are supposed to use the variable method instead, could also use move command instead of ori)
LineType.COMMENT			#ori $s1, $0, 4 	# set s1 (b) to 4 (commented out since I think we are supposed to use the variable method instead, could also use move command instead of ori)
LineType.COMMENT			# Last 2 lines above using variables instead of immediate values:
LineType.INVALID			la $t5, varA 		# place the address of A into register t5
LineType.INVALID			lw $s0, 0($t5) 		# get the outer loop count from varA
LineType.INVALID			la $t6, varB 		# place the address of B into register t6
LineType.INVALID			lw $s1, 0($t6) 		# get the inner loop count from varB
LineType.BLANK			
LineType.LABEL_ONLY		outer_loop:
LineType.COMMENT			# Skip/exit loop if condition is not met
LineType.INVALID			bge $t0, $s0, exit 				# go to exit if i >= a
LineType.INVALID			ori $t1, $0, 0 					# set t1 (j) to zero
LineType.BLANK		
LineType.LABEL_ONLY			inner_loop: 
LineType.COMMENT				# Skip/exit loop if condition is not met
LineType.INVALID				bge $t1, $s1, inner_exit 	# go to exit if j >= b
LineType.BLANK				
LineType.COMMENT				# Compute sum
LineType.INVALID				add $t2, $t0, $t1			# $t2 = i + j
LineType.BLANK				
LineType.COMMENT				# Get address of D[4*j]
LineType.INVALID				sll $t3, $t1, 2 			# $t3 = byte offset amount (j*4)
LineType.INVALID				add $t4, $s2, $t3 			# address = $t4 = base address + byte offset
LineType.BLANK				
LineType.COMMENT				# Store at D[4*j]
LineType.INVALID				sw $t2, 0($t4)				# store $t2 at D[4*j] if j is byte offset or D[j] if you consider it a word offset
LineType.BLANK				
LineType.COMMENT				# Increment j
LineType.INVALID				addi $t1, $t1, 1
LineType.BLANK				
LineType.COMMENT				# loop
LineType.INVALID				j inner_loop
LineType.BLANK			
LineType.LABEL_ONLY			inner_exit:
LineType.BLANK			
LineType.COMMENT			# Increment i
LineType.INVALID			addi $t0, $t0, 1
LineType.BLANK			
LineType.COMMENT			# loop
LineType.INVALID			j outer_loop
LineType.BLANK		
LineType.LABEL_WITH_INSTR		exit:	addi	$v0, $0, 10	# terminate the program with system call #10
LineType.INVALID				syscall
LineType.BLANK		
